  8.14 클래스 안에 포함된 자료형 nested types.cpp
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,20): error C2677: binary '==': no global operator found which takes type 'FruitType' (or there is no acceptable conversion)
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory(3567,17): message : could be 'bool std::operator ==(std::nullptr_t,const std::unique_ptr<_Ty,_Dx> &) noexcept'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(std::nullptr_t,const std::unique_ptr<_Ty,_Dx> &) noexcept': could not deduce template argument for 'const std::unique_ptr<_Ty,_Dx> &' from 'FruitType'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory(3561,30): message : or       'bool std::operator ==(const std::unique_ptr<_Ty,_Dx> &,std::nullptr_t) noexcept'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::unique_ptr<_Ty,_Dx> &,std::nullptr_t) noexcept': could not deduce template argument for 'const std::unique_ptr<_Ty,_Dx>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::unique_ptr<_Ty,_Dx> &,std::nullptr_t) noexcept': could not deduce template argument for 'const std::unique_ptr<_Ty,_Dx> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory(3513,30): message : or       'bool std::operator ==(const std::unique_ptr<_Ty,_Dx> &,const std::unique_ptr<_Ty2,_Dx2> &)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::unique_ptr<_Ty,_Dx> &,const std::unique_ptr<_Ty2,_Dx2> &)': could not deduce template argument for 'const std::unique_ptr<_Ty,_Dx>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::unique_ptr<_Ty,_Dx> &,const std::unique_ptr<_Ty2,_Dx2> &)': could not deduce template argument for 'const std::unique_ptr<_Ty,_Dx> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory(1932,17): message : or       'bool std::operator ==(std::nullptr_t,const std::shared_ptr<_Ty> &) noexcept'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(std::nullptr_t,const std::shared_ptr<_Ty> &) noexcept': could not deduce template argument for 'const std::shared_ptr<_Ty> &' from 'FruitType'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory(1921,17): message : or       'bool std::operator ==(const std::shared_ptr<_Ty> &,std::nullptr_t) noexcept'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::shared_ptr<_Ty> &,std::nullptr_t) noexcept': could not deduce template argument for 'const std::shared_ptr<_Ty>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::shared_ptr<_Ty> &,std::nullptr_t) noexcept': could not deduce template argument for 'const std::shared_ptr<_Ty> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\memory(1879,17): message : or       'bool std::operator ==(const std::shared_ptr<_Ty> &,const std::shared_ptr<_Ty0> &) noexcept'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::shared_ptr<_Ty> &,const std::shared_ptr<_Ty0> &) noexcept': could not deduce template argument for 'const std::shared_ptr<_Ty>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::shared_ptr<_Ty> &,const std::shared_ptr<_Ty0> &) noexcept': could not deduce template argument for 'const std::shared_ptr<_Ty> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring(5034,17): message : or       'bool std::operator ==(const _Elem *const ,const std::basic_string<_Elem,_Traits,_Alloc> &)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const _Elem *const ,const std::basic_string<_Elem,_Traits,_Alloc> &)': could not deduce template argument for 'const _Elem *const ' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring(5015,30): message : or       'bool std::operator ==(const std::basic_string<_Elem,_Traits,_Alloc> &,const _Elem *const )'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::basic_string<_Elem,_Traits,_Alloc> &,const _Elem *const )': could not deduce template argument for 'const std::basic_string<_Elem,_Traits,_Alloc>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::basic_string<_Elem,_Traits,_Alloc> &,const _Elem *const )': could not deduce template argument for 'const std::basic_string<_Elem,_Traits,_Alloc> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring(5009,30): message : or       'bool std::operator ==(const std::basic_string<_Elem,_Traits,_Alloc> &,const std::basic_string<_Elem,_Traits,_Alloc> &) noexcept'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::basic_string<_Elem,_Traits,_Alloc> &,const std::basic_string<_Elem,_Traits,_Alloc> &) noexcept': could not deduce template argument for 'const std::basic_string<_Elem,_Traits,_Alloc>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::basic_string<_Elem,_Traits,_Alloc> &,const std::basic_string<_Elem,_Traits,_Alloc> &) noexcept': could not deduce template argument for 'const std::basic_string<_Elem,_Traits,_Alloc> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory(1034,30): message : or       'bool std::operator ==(const std::allocator<_Ty> &,const std::allocator<_Other> &) noexcept'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::allocator<_Ty> &,const std::allocator<_Other> &) noexcept': could not deduce template argument for 'const std::allocator<_Ty>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::allocator<_Ty> &,const std::allocator<_Other> &) noexcept': could not deduce template argument for 'const std::allocator<_Ty> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator(489,17): message : or       'bool std::operator ==(const std::istreambuf_iterator<_Elem,_Traits> &,const std::istreambuf_iterator<_Elem,_Traits> &)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::istreambuf_iterator<_Elem,_Traits> &,const std::istreambuf_iterator<_Elem,_Traits> &)': could not deduce template argument for 'const std::istreambuf_iterator<_Elem,_Traits>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::istreambuf_iterator<_Elem,_Traits> &,const std::istreambuf_iterator<_Elem,_Traits> &)': could not deduce template argument for 'const std::istreambuf_iterator<_Elem,_Traits> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\iterator(307,17): message : or       'bool std::operator ==(const std::istream_iterator<_Ty,_Elem,_Traits,_Diff> &,const std::istream_iterator<_Ty,_Elem,_Traits,_Diff> &) noexcept'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::istream_iterator<_Ty,_Elem,_Traits,_Diff> &,const std::istream_iterator<_Ty,_Elem,_Traits,_Diff> &) noexcept': could not deduce template argument for 'const std::istream_iterator<_Ty,_Elem,_Traits,_Diff>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::istream_iterator<_Ty,_Elem,_Traits,_Diff> &,const std::istream_iterator<_Ty,_Elem,_Traits,_Diff> &) noexcept': could not deduce template argument for 'const std::istream_iterator<_Ty,_Elem,_Traits,_Diff> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility(4264,5): message : or       'bool std::operator ==(const std::move_iterator<_Iter> &,const std::move_iterator<_Iter2> &) noexcept(<expr>)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::move_iterator<_Iter> &,const std::move_iterator<_Iter2> &) noexcept(<expr>)': could not deduce template argument for 'const std::move_iterator<_Iter>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::move_iterator<_Iter> &,const std::move_iterator<_Iter2> &) noexcept(<expr>)': could not deduce template argument for 'const std::move_iterator<_Iter> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility(1656,5): message : or       'bool std::operator ==(const std::reverse_iterator<_BidIt> &,const std::reverse_iterator<_BidIt2> &) noexcept(<expr>)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::reverse_iterator<_BidIt> &,const std::reverse_iterator<_BidIt2> &) noexcept(<expr>)': could not deduce template argument for 'const std::reverse_iterator<_BidIt>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::reverse_iterator<_BidIt> &,const std::reverse_iterator<_BidIt2> &) noexcept(<expr>)': could not deduce template argument for 'const std::reverse_iterator<_BidIt> &' from 'overloaded-function'
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility(482,27): message : or       'bool std::operator ==(const std::pair<_Ty1,_Ty2> &,const std::pair<_Uty1,_Uty2> &)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::pair<_Ty1,_Ty2> &,const std::pair<_Uty1,_Uty2> &)': could not deduce template argument for 'const std::pair<_Ty1,_Ty2>' from 'FruitType (void)'
E:\github_Desktop\HongJungMo-CPP\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types\8.14 클래스 안에 포함된 자료형 nested types.cpp(25,11): message : 'bool std::operator ==(const std::pair<_Ty1,_Ty2> &,const std::pair<_Uty1,_Uty2> &)': could not deduce template argument for 'const std::pair<_Ty1,_Ty2> &' from 'overloaded-function'
